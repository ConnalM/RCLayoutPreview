using Newtonsoft.Json.Linq;
using RCLayoutPreview.Helpers;
using System;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Input;
using System.Windows.Controls.Primitives;

namespace RCLayoutPreview
{
    public partial class MainWindow : Window
    {
        private string currentJsonPath;
        private JObject jsonData;
        private DispatcherTimer previewTimer;
        private string lastEditorContent = string.Empty;
        private TextBlock statusLabel;
        private bool autoUpdateEnabled = true; // Flag to control auto-update
        private int previewDelayMilliseconds = 3000; // Configurable delay in milliseconds
        private DateTime lastEditTime;

        // Manual splitter handling
        private Border activeSplitter = null;
        private Point startDragPoint;
        private double fieldsStartWidth;
        private double editorStartWidth;
        private double editorStartLeft;
        private double previewStartLeft;

        // Minimum sizes
        private const double MIN_PANEL_WIDTH = 100;
        private const double MIN_EDITOR_WIDTH = 200;

        public MainWindow()
        {
            InitializeComponent();

            // Initialize UI elements
            statusLabel = FindName("StatusLabel") as TextBlock;
            HideButton("Load JSON");
            HideButton("Preview");

            // Load JSON data automatically
            LoadStubData();

            // Clear the preview area initially
            var previewHost = FindName("PreviewHost") as ContentControl;
            if (previewHost != null)
            {
                previewHost.Content = null;
            }

            // Set up timer for automatic preview
            previewTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(500)
            };
            previewTimer.Tick += AutoPreviewTick;
            previewTimer.Start();

            // Populate JSON fields tree
            PopulateJsonFieldsTree();

            // Size change event for canvas
            MainCanvas.SizeChanged += MainCanvas_SizeChanged;

            // Log when window is fully loaded
            this.Loaded += MainWindow_Loaded;
        }

        private void MainCanvas_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            UpdatePreviewPanel();
        }

        private void UpdatePreviewPanel()
        {
            try
            {
                // Maintain a fixed width for the preview panel
                double previewWidth = Math.Max(200, MainCanvas.ActualWidth - Canvas.GetLeft(PreviewScrollViewer) - 10);
                PreviewScrollViewer.Width = previewWidth;

                // Update the position of the preview panel based on the splitter
                double editorRightEdge = Canvas.GetLeft(EditorPanel) + EditorPanel.Width;
                Canvas.SetLeft(PreviewScrollViewer, editorRightEdge + 5);

                LogStatus($"Preview panel updated: Width={PreviewScrollViewer.Width}, Left={Canvas.GetLeft(PreviewScrollViewer)}");
            }
            catch (Exception ex)
            {
                LogStatus($"Error updating preview panel: {ex.Message}");
            }
        }

        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // Log initial sizes for diagnostics
            LogStatus("Layout initialized. Splitters should now work independently.");

            // Initial update after window is loaded
            Dispatcher.BeginInvoke(new Action(() =>
            {
                UpdatePreviewPanel();
            }), DispatcherPriority.Loaded);
        }

        // Manual splitter handling
        private void Splitter_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed)
            {
                // Remember which splitter is being dragged
                activeSplitter = sender as Border;

                // Capture mouse and record starting positions
                activeSplitter.CaptureMouse();
                startDragPoint = e.GetPosition(MainCanvas);

                // Store initial widths and positions
                fieldsStartWidth = FieldsPanel.Width;
                editorStartWidth = EditorPanel.Width;
                editorStartLeft = Canvas.GetLeft(EditorPanel);
                previewStartLeft = Canvas.GetLeft(PreviewScrollViewer);

                // Log which splitter is active
                LogStatus($"Dragging {(activeSplitter.Name == "FieldsEditorSplitter" ? "Fields/Editor" : "Editor/Preview")} splitter");

                e.Handled = true;
            }
        }

        private void Splitter_MouseMove(object sender, MouseEventArgs e)
        {
            if (activeSplitter != null && e.LeftButton == MouseButtonState.Pressed)
            {
                // Calculate the drag distance
                Point currentPosition = e.GetPosition(MainCanvas);
                double horizontalChange = currentPosition.X - startDragPoint.X;

                if (Math.Abs(horizontalChange) > 2) // Small threshold to avoid tiny movements
                {
                    if (activeSplitter.Name == "FieldsEditorSplitter")
                    {
                        // Update FieldsPanel and EditorPanel only
                        double newFieldsWidth = Math.Max(MIN_PANEL_WIDTH, fieldsStartWidth + horizontalChange);
                        FieldsPanel.Width = newFieldsWidth;
                        Canvas.SetLeft(FieldsEditorSplitter, newFieldsWidth);
                        Canvas.SetLeft(EditorPanel, newFieldsWidth + 5);

                        LogStatus($"FieldsEditorSplitter moved: FieldsPanel.Width={FieldsPanel.Width}, EditorPanel.Left={Canvas.GetLeft(EditorPanel)}");
                    }
                    else if (activeSplitter.Name == "EditorPreviewSplitter")
                    {
                        // Update EditorPanel and PreviewScrollViewer only
                        double newEditorWidth = Math.Max(MIN_EDITOR_WIDTH, editorStartWidth + horizontalChange);
                        EditorPanel.Width = newEditorWidth;
                        Canvas.SetLeft(EditorPreviewSplitter, editorStartLeft + newEditorWidth);
                        Canvas.SetLeft(PreviewScrollViewer, editorStartLeft + newEditorWidth + 5);

                        LogStatus($"EditorPreviewSplitter moved: EditorPanel.Width={EditorPanel.Width}, PreviewScrollViewer.Left={Canvas.GetLeft(PreviewScrollViewer)}");
                    }

                    // Update preview size
                    UpdatePreviewPanel();
                    e.Handled = true;
                }
            }
        }

        private void Splitter_MouseUp(object sender, MouseButtonEventArgs e)
        {
            if (activeSplitter != null)
            {
                // Release mouse capture
                activeSplitter.ReleaseMouseCapture();

                // Log the final dimensions
                LogStatus($"Splitter set - Fields: {FieldsPanel.Width:F0}, Editor: {EditorPanel.Width:F0}");

                // Reset active splitter
                activeSplitter = null;
                e.Handled = true;
            }
        }

        private void Window_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            if (e.PreviousSize.Width > 0 && e.PreviousSize.Width != e.NewSize.Width)
            {
                // Only need to update the preview panel
                UpdatePreviewPanel();
                LogStatus($"Window resized to {e.NewSize.Width:F0}px wide");
            }
        }

        private void HideButton(string buttonContent)
        {
            foreach (var child in LogicalTreeHelper.GetChildren(this))
            {
                if (child is Grid grid)
                {
                    foreach (var gridChild in LogicalTreeHelper.GetChildren(grid))
                    {
                        if (gridChild is StackPanel stackPanel)
                        {
                            foreach (var stackChild in LogicalTreeHelper.GetChildren(stackPanel))
                            {
                                if (stackChild is Button button && button.Content.ToString() == buttonContent)
                                {
                                    // Remove hiding logic for Preview button
                                    if (buttonContent == "Preview")
                                    {
                                        button.Visibility = Visibility.Visible;
                                        return;
                                    }

                                    button.Visibility = Visibility.Collapsed;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }

        private void AutoPreviewTick(object sender, EventArgs e)
        {
            if (!autoUpdateEnabled) return; // Skip auto-update if disabled

            var editor = FindName("Editor") as TextBox;
            if (editor != null)
            {
                string currentContent = editor.Text;
                if (currentContent != lastEditorContent && !string.IsNullOrWhiteSpace(currentContent))
                {
                    lastEditTime = DateTime.Now;
                    lastEditorContent = currentContent;
                }

                // Check if the delay has elapsed since the last edit
                if ((DateTime.Now - lastEditTime).TotalMilliseconds >= previewDelayMilliseconds)
                {
                    TryPreviewXaml(currentContent);
                }
            }
        }

        private void TryPreviewXaml(string xamlContent)
        {
            if (string.IsNullOrWhiteSpace(xamlContent))
            {
                LogStatus("XAML content is empty or null.");
                return;
            }

            try
            {
                var previewHost = FindName("PreviewHost") as ContentControl;
                if (previewHost == null)
                {
                    LogStatus("Preview host is not found.");
                    return;
                }

                // Clear the preview host before updating
                previewHost.Content = null;

                string processedXaml = XamlFixer.Preprocess(xamlContent);
                LogStatus("XAML processed for preview");

                // Validate XAML for common issues
                if (processedXaml.Contains("FontSize=\"\""))
                {
                    LogStatus("Invalid FontSize detected in XAML. Replacing with default value.");
                    processedXaml = processedXaml.Replace("FontSize=\"\"", "FontSize=\"14\"");
                }

                object element = System.Windows.Markup.XamlReader.Parse(processedXaml);
                if (element is Window window)
                {
                    LogStatus("XAML contains a Window element. Extracting content.");
                    element = window.Content;
                }

                if (element is FrameworkElement frameworkElement)
                {
                    if (jsonData == null)
                    {
                        LogStatus("JSON data is null. Cannot bind values.");
                        return;
                    }

                    // Apply JSON data to the DataContext
                    frameworkElement.DataContext = jsonData;

                    // Use XamlFixer to process named fields
                    LogStatus("Processing named fields...");
                    XamlFixer.ProcessNamedFields(frameworkElement, jsonData, debugMode: true);

                    previewHost.Content = frameworkElement;
                    LogStatus("Preview updated successfully.");
                }
                else
                {
                    LogStatus("Parsed XAML does not contain a valid FrameworkElement.");
                }
            }
            catch (XamlParseException ex)
            {
                ShowErrorPopup($"XAML parsing error: {ex.Message}");
            }
            catch (Exception ex)
            {
                ShowErrorPopup($"Preview error: {ex.Message}");
            }
        }

        public static T FindElementByName<T>(DependencyObject parent, string name) where T : FrameworkElement
        {
            if (parent == null) return null;

            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (child is T fe && fe.Name == name)
                    return fe;

                var result = FindElementByName<T>(child, name);
                if (result != null)
                    return result;
            }

            return null;
        }

        private void ShowErrorPopup(string errorMessage)
        {
            var layoutRoot = PreviewHost.Content as FrameworkElement;
            var popupOverlay = FindElementByName<Grid>(layoutRoot, "PopupOverlay");
            var popupMessage = FindElementByName<TextBlock>(layoutRoot, "PopupMessage");

            if (popupOverlay == null)
            {
                LogStatus("PopupOverlay not found in the visual tree.");
                return;
            }

            if (popupMessage == null)
            {
                LogStatus("PopupMessage not found in the visual tree.");
                return;
            }

            popupMessage.Text = errorMessage;
            Dispatcher.BeginInvoke(() =>
            {
                popupOverlay.Visibility = Visibility.Visible;
                popupOverlay.UpdateLayout(); // Force layout update
                LogStatus("PopupOverlay visibility set to Visible.");
            });
            LogStatus("Popup overlay displayed with message: " + errorMessage);
        }

        private void PopupOkButton_Click(object sender, RoutedEventArgs e)
        {
            var popupOverlay = FindName("PopupOverlay") as Grid;
            if (popupOverlay != null)
            {
                popupOverlay.Visibility = Visibility.Collapsed;
            }
        }

        private void LoadStubData()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            LogStatus($"Base directory: {baseDirectory}");

            string jsonPath = Path.Combine(baseDirectory, "stubdata5.json");
            LogStatus($"Checking path: {jsonPath}");

            if (File.Exists(jsonPath))
            {
                try
                {
                    currentJsonPath = jsonPath;
                    string jsonContent = File.ReadAllText(jsonPath);

                    // Clear and reload JSON data
                    jsonData = JObject.Parse(jsonContent);
                    LogStatus($"Loaded JSON: {Path.GetFileName(jsonPath)}");

                    // Populate JSON fields tree
                    PopulateJsonFieldsTree();

                    return;
                }
                catch (Exception ex)
                {
                    LogStatus($"Error parsing JSON file: {ex.Message}");
                }
            }
            else
            {
                LogStatus($"File does not exist: {jsonPath}");
            }

            LogStatus("No JSON data files found.");
        }

        private void LogStatus(string message)
        {
            if (statusLabel != null)
            {
                statusLabel.Text = message;
            }
            Console.WriteLine($"Status: {message}");
        }

        private void LoadLayout_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new Microsoft.Win32.OpenFileDialog
            {
                Filter = "XAML Layout (*.xaml)|*.xaml",
                Title = "Select Layout XAML"
            };

            if (dlg.ShowDialog() == true)
            {
                var editor = FindName("Editor") as TextBox;
                if (editor != null)
                {
                    try
                    {
                        string xamlContent = File.ReadAllText(dlg.FileName);
                        editor.Text = xamlContent;
                        LogStatus($"Loaded layout: {Path.GetFileName(dlg.FileName)}");

                        // Force an immediate preview
                        TryPreviewXaml(xamlContent);
                    }
                    catch (Exception ex)
                    {
                        LogStatus($"Error loading layout: {ex.Message}");
                    }
                }
            }
        }

        private void LoadJson_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new Microsoft.Win32.OpenFileDialog
            {
                Filter = "JSON Data (*.json)|*.json",
                Title = "Select JSON Data",
                FileName = "stubdata5.json" // Default to stubdata5.json
            };

            if (dlg.ShowDialog() == true)
            {
                try
                {
                    currentJsonPath = dlg.FileName;
                    string json = File.ReadAllText(dlg.FileName);
                    jsonData = JObject.Parse(json);

                    LogStatus($"Loaded: {Path.GetFileName(dlg.FileName)}");

                    // Populate JSON fields tree
                    PopulateJsonFieldsTree();

                    // Update preview with new data
                    var editor = FindName("Editor") as TextBox;
                    if (editor != null && !string.IsNullOrWhiteSpace(editor.Text))
                    {
                        TryPreviewXaml(editor.Text);
                    }
                }
                catch (Exception ex)
                {
                    LogStatus($"Error loading JSON: {ex.Message}");
                }
            }
        }

        private void Preview_Click(object sender, RoutedEventArgs e)
        {
            var editor = FindName("Editor") as TextBox;
            if (editor != null && !string.IsNullOrWhiteSpace(editor.Text))
            {
                var layoutRoot = PreviewHost.Content as FrameworkElement;
                var popupOverlay = FindElementByName<Grid>(layoutRoot, "PopupOverlay");
                Console.WriteLine("Found popupOverlay: " + (popupOverlay != null));

                TryPreviewXaml(editor.Text);
            }
        }

        private void SaveLayout_Click(object sender, RoutedEventArgs e)
        {
            var editor = FindName("Editor") as TextBox;
            if (editor != null && !string.IsNullOrWhiteSpace(editor.Text))
            {
                var dlg = new Microsoft.Win32.SaveFileDialog
                {
                    Filter = "XAML Layout (*.xaml)|*.xaml",
                    Title = "Save Layout XAML"
                };

                if (dlg.ShowDialog() == true)
                {
                    File.WriteAllText(dlg.FileName, editor.Text);
                    LogStatus($"Saved layout to: {Path.GetFileName(dlg.FileName)}");
                }
            }
            else
            {
                LogStatus("Nothing to save. Editor is empty.");
            }
        }

        private void DebugModeToggle_Changed(object sender, RoutedEventArgs e)
        {
            var debugMode = (sender as CheckBox)?.IsChecked == true;
            LogStatus(debugMode ? "Debug mode enabled" : "Debug mode disabled");

            // Update the preview if we have content
            var editor = FindName("Editor") as TextBox;
            if (editor != null && !string.IsNullOrWhiteSpace(editor.Text))
            {
                TryPreviewXaml(editor.Text);
            }
        }

        private void AutoUpdateToggle_Changed(object sender, RoutedEventArgs e)
        {
            var autoUpdate = (sender as CheckBox)?.IsChecked == true;
            ToggleAutoUpdate(autoUpdate);
        }

        private void ToggleAutoUpdate(bool enable)
        {
            autoUpdateEnabled = enable;
            LogStatus(enable ? "Auto-update enabled" : "Auto-update disabled");
        }

        private void DelayInput_TextChanged(object sender, TextChangedEventArgs e)
        {
            var delayInput = (sender as TextBox)?.Text;
            if (int.TryParse(delayInput, out var delay))
            {
                previewDelayMilliseconds = delay;
                LogStatus($"Preview delay updated to {previewDelayMilliseconds} ms.");
            }
            else
            {
                LogStatus("Invalid delay input. Please enter a valid number.");
            }
        }

        private void JsonFieldsTree_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var treeView = sender as TreeView;
            var selectedItem = treeView?.SelectedItem as TreeViewItem;
            if (selectedItem != null)
            {
                DragDrop.DoDragDrop(treeView, selectedItem.Header.ToString(), DragDropEffects.Copy);
            }
        }

        private void JsonFieldsTree_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var treeView = sender as TreeView;
            var selectedItem = treeView?.SelectedItem as TreeViewItem;
            if (selectedItem != null)
            {
                var editor = FindName("Editor") as TextBox;
                if (editor != null)
                {
                    editor.SelectedText = selectedItem.Header.ToString(); // Insert the field at the cursor position
                }
            }
        }

        private void Editor_Drop(object sender, DragEventArgs e)
        {
            var editor = sender as TextBox;
            if (editor != null && e.Data.GetDataPresent(DataFormats.StringFormat))
            {
                var droppedText = e.Data.GetData(DataFormats.StringFormat) as string;
                editor.SelectedText = droppedText; // Insert the dropped text at the cursor position
            }
        }

        private void PopulateJsonFieldsTree()
        {
            if (jsonData == null) return;

            var jsonFieldsTree = FindName("JsonFieldsTree") as TreeView;
            if (jsonFieldsTree == null) return;

            jsonFieldsTree.Items.Clear();

            foreach (var property in jsonData.Properties())
            {
                var groupItem = new TreeViewItem { Header = property.Name };
                if (property.Value is JObject groupObj)
                {
                    foreach (var field in groupObj.Properties())
                    {
                        var fieldItem = new TreeViewItem { Header = field.Name };
                        groupItem.Items.Add(fieldItem);
                    }
                }
                jsonFieldsTree.Items.Add(groupItem);
            }
        }
    }
}